{"ast":null,"code":"import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport { trackStream } from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport { progressEventReducer, progressEventDecorator, asyncDecorator } from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst {\n  isFunction\n} = utils;\n\nconst globalFetchAPI = (_ref => {\n  let {\n    Request,\n    Response\n  } = _ref;\n  return {\n    Request,\n    Response\n  };\n})(utils.global);\n\nconst {\n  ReadableStream,\n  TextEncoder\n} = utils.global;\n\nconst test = function (fn) {\n  try {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return !!fn(...args);\n  } catch (e) {\n    return false;\n  }\n};\n\nconst factory = env => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n  const {\n    fetch: envFetch,\n    Request,\n    Response\n  } = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Request(str).arrayBuffer()));\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      }\n\n    }).headers.has('Content-Type');\n    return duplexAccessed && !hasContentType;\n  });\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils.isReadableStream(new Response('').body));\n  const resolvers = {\n    stream: supportsResponseStream && (res => res.body)\n  };\n  isFetchSupported && (() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n    });\n  })();\n\n  const getBodyLength = async body => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body\n      });\n\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  };\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n    return length == null ? getBodyLength(body) : length;\n  };\n\n  return async config => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader);\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      } // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n\n\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n      const resolvedOptions = { ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n      request = isRequestSupported && new Request(url, resolvedOptions);\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n        const options = {};\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];\n        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }), options);\n      }\n\n      responseType = responseType || 'text';\n      let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n      !isStreamResponse && unsubscribe && unsubscribe();\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        });\n      });\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {\n          cause: err.cause || err\n        });\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  };\n};\n\nconst seedCache = new Map();\nexport const getFetch = config => {\n  let env = config ? config.env : {};\n  const {\n    fetch,\n    Request,\n    Response\n  } = env;\n  const seeds = [Request, Response, fetch];\n  let len = seeds.length,\n      i = len,\n      seed,\n      target,\n      map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n    target === undefined && map.set(seed, target = i ? new Map() : factory(env));\n    map = target;\n  }\n\n  return target;\n};\nconst adapter = getFetch();\nexport default adapter;","map":{"version":3,"names":["platform","utils","AxiosError","composeSignals","trackStream","AxiosHeaders","progressEventReducer","progressEventDecorator","asyncDecorator","resolveConfig","settle","DEFAULT_CHUNK_SIZE","isFunction","globalFetchAPI","Request","Response","global","ReadableStream","TextEncoder","test","fn","args","e","factory","env","merge","call","skipUndefined","fetch","envFetch","isFetchSupported","isRequestSupported","isResponseSupported","isReadableStreamSupported","encodeText","encoder","str","encode","Uint8Array","arrayBuffer","supportsRequestStream","duplexAccessed","hasContentType","origin","body","method","duplex","headers","has","supportsResponseStream","isReadableStream","resolvers","stream","res","forEach","type","config","ERR_NOT_SUPPORT","getBodyLength","isBlob","size","isSpecCompliantForm","_request","byteLength","isArrayBufferView","isArrayBuffer","isURLSearchParams","isString","resolveBodyLength","length","toFiniteNumber","getContentLength","url","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","_fetch","toLowerCase","composedSignal","toAbortSignal","request","unsubscribe","requestContentLength","contentTypeHeader","isFormData","get","setContentType","onProgress","flush","isCredentialsSupported","prototype","resolvedOptions","toUpperCase","normalize","toJSON","credentials","undefined","response","isStreamResponse","options","prop","responseContentLength","responseData","findKey","Promise","resolve","reject","from","status","statusText","err","name","message","Object","assign","ERR_NETWORK","cause","code","seedCache","Map","getFetch","seeds","len","i","seed","target","map","set","adapter"],"sources":["/Users/min/Documents/GitHub/React---06/node_modules/axios/lib/adapters/fetch.js"],"sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst {isFunction} = utils;\n\nconst globalFetchAPI = (({Request, Response}) => ({\n  Request, Response\n}))(utils.global);\n\nconst {\n  ReadableStream, TextEncoder\n} = utils.global;\n\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst factory = (env) => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n\n  const {fetch: envFetch, Request, Response} = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n      async (str) => new Uint8Array(await new Request(str).arrayBuffer())\n  );\n\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  });\n\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&\n    test(() => utils.isReadableStream(new Response('').body));\n\n  const resolvers = {\n    stream: supportsResponseStream && ((res) => res.body)\n  };\n\n  isFetchSupported && ((() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n    });\n  })());\n\n  const getBodyLength = async (body) => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body,\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  }\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n\n    return length == null ? getBodyLength(body) : length;\n  }\n\n  return async (config) => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (\n        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n        (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n      ) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader)\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(\n            requestContentLength,\n            progressEventReducer(asyncDecorator(onUploadProgress))\n          );\n\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n\n      request = isRequestSupported && new Request(url, resolvedOptions);\n\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n        const options = {};\n\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n          responseContentLength,\n          progressEventReducer(asyncDecorator(onDownloadProgress), true)\n        ) || [];\n\n        response = new Response(\n          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }),\n          options\n        );\n      }\n\n      responseType = responseType || 'text';\n\n      let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n      !isStreamResponse && unsubscribe && unsubscribe();\n\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        })\n      })\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(\n          new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n          {\n            cause: err.cause || err\n          }\n        )\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  }\n}\n\nconst seedCache = new Map();\n\nexport const getFetch = (config) => {\n  let env = config ? config.env : {};\n  const {fetch, Request, Response} = env;\n  const seeds = [\n    Request, Response, fetch\n  ];\n\n  let len = seeds.length, i = len,\n    seed, target, map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n\n    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)))\n\n    map = target;\n  }\n\n  return target;\n};\n\nconst adapter = getFetch();\n\nexport default adapter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}